\section{Implementation}
In this section we want to give a high level explanation of our implementation for mining and processing the data we use to tend to our research questions. We first discuss the mining process and secondly the processing of the mined data.
\subsection{Mining the data}
In order to answer the three research questions we need information about the maintainability of a project, all the refactors which are made and the correlation between these two datasets. To collect this information the tool \textit{Repodriller} was used to iterate through all the commits of a repository and checkout each commit in order to process each file in the current state of the repository when the commit was made. However, we were not able to mine all the information at once, so we decided to make 2 different data-mining jobs: the \textbf{monthly metrics job} and the \textbf{refactoring job}. For both of these jobs we have decided to mine only the last 5 years of each project's history. We made this choice to reduce the amount of time the jobs would take to run and this way we still have a significant part of the project's history.

The monthly metrics job is the first data-mining job which collects all the information about the maintainability and the production-test pairs from the commits of a project on a monthly basis. We calculate all the metrics with the \textit{CK} tool which are described in section \ref{Researchtools}. 
%When all these metrics are calculated, we count all the operators and operands in order to calculate the \textit{Hallstead Volume}. We use the \textit{Hallstead Volume} together with the \textit{LOC} and the \textit{WMC} to calculate the \textit{Maintainability Index}. 

From this point on we have all the metrics which are relevant to the maintainability of the file, which we can use for the \textit{Monthly Metrics} file. In order to find the correlation between the production and test code, we have to find the production-test pairs. Because all the repositories exists out of either gradle or maven projects, we can find the relevant test file of each production file by naming conventions and by using the project structure. JUnit test classes are often named after their respective production classname + Test, so for example a production class "FileCacheProvider" would have a test class called "FileCacheProviderTest". Java projects often have a structure with a "main" and "test" source folder, each having a similar substructure, making finding test classes easier. The found pairs we write to the \textit{class-pair file}.

The refactoring job is the second data-mining job which collects all the information about the refactors of test classes and tracks matching production classes of test classes. First we check if there are actually any refactors made in the commit. If this is not the case we can skip the whole commit because it contains no relevant information for this research. However, if the commit does contain refactors we collect all the refactor methods which were used on the test code and write this information to the \textit{test refactor file}. We then fetch the matching production class from the \textit{class-pair file} and calculate the metrics of this file every 10 commits for 5 versions, 10-20-30 etc commits after the test refactoring had taken place. We write the metrics of the tracked production files to the \textit{impact production file} with the commithash of the commit in which the test refactoring happened as an identifier. When this information is collected we tend to the correlation between refactors on test code and the maintainability of the production code. 

\subsection{Processing the data}
For processing the collected data we have used several methods, for research question 1 it was sufficient to use Microsoft Excel for counting the different types of refactorings found in the \textit{test refactors file}.

For research question 2 and 3 we have written a Java implementation that loads the relevant files and the plots that will be seen later in this work were made using JFreeChart \footnote{http://www.jfree.org/jfreechart/}. We would like to point the reader to the public git repository where the code as well as the found data is hosted \footnote{https://github.com/Dahny/Software\_Analytics}.